// Requires
var http = require('http');
var sys = require("sys");
var child = require("child_process");
var url = require("url");
var path = require("path");
var fs = require("fs");
var events = require("events");
var mongoose = require("mongoose");
var duodb = process.env['DUOSTACK_DB_MONGODB'];
var localhost = "mongodb://localhost/test";
var db = mongoose.connect(duodb);


// Configurables
var irc_host = "irc.freenode.net";
var irc_user = "_npm_";
var irc_channels = ["#fusspawn"]; //use #fusspawn for testing but duostack for logging. mainly because the duostack guys are awesome.
var control_key = "!!1234!!";  //set this to your unique password. TODO: check nicks against allowed whitelist.

// App Data
var channel_logs = {};
var chan_messages = new Array();
var max_chan_saved = 30;
var irc_output = new Array();
var irc_dump_timer = setInterval(do_output, 1000); // this is part of the buffering system

// Stats
var requests_served = 0;
var messages_read = 0;

// DEBUGGER

// Helpers
String.prototype.startsWith = function(str) {
return (this.match("^"+str)==str)
}

String.prototype.parseCommand= function(str) {
	return this.split(" ");
}


// MODELS
var LogMessage = new mongoose.Schema({
		from: String,
		to: String,
		body: String,
		at: Date
});

mongoose.model("LogMessage",  LogMessage);
// PROGRAM

//sends a static file request out.
function load_static_file(uri, response) {
	var filename = path.join(process.cwd(), uri);
	path.exists(filename, function(exists) {
		if(!exists) {
			response.writeHead(404, {"Content-Type": "text/plain"});
			response.write("404 Not Found\n");
			response.end();
			return;
		}

		fs.readFile(filename, "binary", function(err, file) {
			if(err) {
				response.writeHead(500, {"Content-Type": "text/plain"});
				response.write(err + "\n");
				response.end();
				return;
			}

			response.writeHead(200);
			response.write(file, "binary");
			response.end();
		});
	});
}

//create the simple server
http.createServer(function (req, res) {
	  do_web_request(req, res);
}).listen(80, "127.0.0.1");
console.log('Server running at http://127.0.0.1:80/');
console.log("Starting IRC Instance");

// Create IRC server
var irc = require('irc');
var client = new irc.Client(irc_host, irc_user, {
    channels: irc_channels,
});

// Register IRC Handlers
client.addListener('message', function (from, to, message) {
	messages_read++;
	
     // handle npm commands
    if(message.trim().startsWith("!npm")) {
		run_npm(from, to, message);
		return;
	}
	
	//handle join requests
	if(message.trim().startsWith("!join")) {
		do_join(from, to, message);
	}
	
	// handle part requests needs a password
	if(message.trim().startsWith("!part")) {
		do_part(from, to, message);
	}
	
	// handle stats
	if(message.trim().startsWith("!stats")) {
		client.say(from, "I have seen "+messages_read+" lines of text and responded to "+requests_served+" commands");
		return;
	}
	
	
	if(message.trim().startsWith("!channel")) {
		do_channel(from, to, message);
	}
	
	if(message.trim().startsWith("!clear")){
		do_clear(from, to ,message)
	}
	
	// if the message is on the duostack channel log it for displaying in browser
	if(to == "#duostack") {
		var item = {};
		item.body = message;
		item.from = from;
		item.to = to;	
		item.at = new Date().now;
		
		if(chan_messages.length > max_chan_saved - 1) // we only need to keep the last 30 messages
				chan_messages.shift();
		
		chan_messages.push(item);
	}
	
	  save_log_message(from, to, message);	
});

// Simple ERROR Handler
client.addListener("error", function(message) {
	sys.puts(message); //log it and continue, for now hacky!
});

function do_clear(from, to, message) {
	for(var i = 0; i < irc_output.length; i++) {
		if(irc_output[i].to == from) {
			irc_output[i].sendable = false;
		}
	}
}

function do_web_request(request, response) {
	 var urls = url.parse(request.url, true);
	 
	 if(urls.pathname.startsWith("/static"))
			load_static_file(urls.pathname, response);
			
	if(urls.pathname === "/irc_list") {
		  response.writeHead(200, {'Content-Type': 'text/html'});
		  for(var i =0; i < chan_messages.length; i++) {
				response.write("<li> "+chan_messages[i].from + ": "+chan_messages[i].body+ "</li>");
		   }
		  response.end('');
	}
	
	if(urls.pathname.startsWith("/history")) {
		console.log("doing mongo hist:" + urls.query.channel);
		response.writeHead(200, {'Content-Type': 'text/html'});
		get_mongo_logs(urls.query.channel, function(logs) {
				if(!logs) {
					response.end("No Logs Found");
				}
				else {
					response.write("<ul>");
					for(var i=0; i < logs.length; i++) {
						response.write("<li> "+logs[i].from + ": "+logs[i].body+ "</li>");
					}
					response.end("</ul>");
				}
		});
	} 
}


function get_mongo_logs(channel, callback) {
		var logs = new Array();
		var LogMessage = mongoose.model("LogMessage");
		
		LogMessage.find({to: "#"+channel},  function(err, documents) 
		{
			documents.forEach(function(document) {  if(document != null) logs.push(document); });
			callback(logs);
		});
}

// Handle !channel messages
function do_channel(from, to, message) {
	var commandparts = message.parseCommand();
		if(commandparts.length < 2) {
			write_irc_message(from, "invalid args: usage: !channel #channel");
			return;
		}
		else {
				if(!channel_logs[to]) {
					write_irc_message(from, "No Logs Found");
				} else {
					for(var i = 0; i < channel_logs[commandparts[1]].length; i++)
					{
						write_irc_message(from, channel_logs[commandparts[1]][i].from + ": " +channel_logs[commandparts[1]][i].body);
					}
					write_irc_message(from, "end of logs");
				}
		}
		return;
}

// Handle !part messages
function do_part(from, to, message) {
	    var commandparts = message.parseCommand();
		if(commandparts.length < 3) {
			client.say(from, "invalid args: usage: !part #channel password");
			return;
		}
		else {
			if(commandparts[2] == control_key) {
				client.part(commandparts[1]);
				client.say(from, "parted: "+commandparts[1]);
			} else {
				client.say(from, "unable to part: Invalid Password");
			}
		}
		return;
}

// Handle !join messages
function do_join(from, to, message) {
		var commandparts = message.parseCommand();
		if(commandparts.length < 2) {
			client.say(from, "invalid args: usage: !join #channel");
			return;
		}
		else {
			client.join(commandparts[1]);
			client.say(from, "joined: "+commandparts[1]);
		}
		return;
}

// save a log message
function save_log_message(from, to, message) {
	var item = {};
	item.body = message;
	item.from = from;
	item.to = to;
	item.at = new Date().now;
	
	if(!channel_logs[to])
		channel_logs[to] = new Array();
		
	channel_logs[to].push(item);
	
	var LogMessage = mongoose.model("LogMessage");
	var log = new LogMessage();
	log.body = message;
	log.from = from;
	log.to = to;
	log.at = item.at;
	
	log.save();
}

//from = who sent the message, to = channel or user, message = fulltext
function run_npm(from, to, message) {
		requests_served++;
		//example command: !npm search express
		var commandparts = message.split(" ");
		var arguments = Array();
		for(var i = 1; i < commandparts.length; i++) // we dont need the !npm part todo: forbid certain commands install exctra. meanwhile limited to working in my test channel
			arguments.push(commandparts[i]);
		
        var npm = child.spawn(".ds_npm_bin/npm", arguments); //spawn npm process with passed in args TODO: Stop use of install exctra. use a whitelist of accepted commands
		console.log("npm spawned");
		
		write_irc_message(from, "please wait..");
		write_irc_message(from, "running "+message+"...");
		//THIS IS THE PART THAT FAILS ON DUOSTACK - OR AT LEAST NEVER GETS CALLED - I PRESUME A MISSING NPM LOGS SHOW NOTHING
		npm.stdout.on("data", function(data) {
			var lines = data.toString().split("\n"); // Something went screwy while sending irc messages with a newline. so split it.
			for(var i=0; i < lines.length; i++) {
				write_irc_message(from, lines[i]);
			}
			write_irc_message(from, "<!-- end of data --!>");
        });
}

//called once a second and handles outputting messages from the buffer to irc.
function do_output() {
	if(irc_output.length > 0) {
		var line = irc_output.shift();
		client.say(line.to, line.message);
	}
}

// write a buffered IRC message
function write_irc_message(to, message) {
	var message_item = {}
	message_item.to = to;
	message_item.message = message;
	message_item.sendable = true;
	irc_output.push(message_item);
}